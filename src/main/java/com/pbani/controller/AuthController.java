package com.pbani.controller;

import com.pbani.exceptions.UserException;
import com.pbani.payload.dto.UserDto;
import com.pbani.payload.response.AuthResponse;
import com.pbani.service.AuthService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/auth")
@RequiredArgsConstructor
public class AuthController {
    /*
    For this field below, spring injects the service into the field so that the signup handler method can be used
    because this field is marked with the final keyword, java requires that the field must be initialized when the AuthController is created
    On start, @RestController annotation creates an instance of AuthController, sees it requires an AuthService, looks through the applcation context, finds the class marked @Service in (AuthServiceImpl) and passes that through the auth controller constructor which is automatically generated by Lombok
     */
       private final AuthService authService;

    //api endpoint: localhost:5000/auth/signup

    @PostMapping("/signup")
    public ResponseEntity<AuthResponse> signupHandler(
            @RequestBody UserDto userDto
    ) throws UserException {
        return ResponseEntity.ok(
                //this should be .signup I believe?
                authService.register(userDto)
        );
    }

    @PostMapping("/login")
    public ResponseEntity<AuthResponse> loginHandler(
            @RequestBody UserDto userDto
    ) throws UserException {
        return ResponseEntity.ok(
                authService.login(userDto)
        );
    }
}
